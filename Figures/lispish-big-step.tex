\begin{figure}[H]
\singlespacing
\centering
Operators:\
\[
\inference[bop]{E_1, s \ $$\Downarrow$$ \ b_1, s' \ E_2, s' \ $$\Downarrow$$ \ b_2, s''}
{(bop \ E_1 \ E_2) \ $$\Downarrow$$ \ b, s'', if (= b \ (bop \ b_1 \ b_2))}
\]
\[
\inference[op]{E_1, s \ $$\Downarrow$$ \ n_1, s' \ E_2, s' \ $$\Downarrow$$ \ n_2, s''}
{(op \ E_1 \ E_2) \ $$\Downarrow$$ \ b, s'', if (= b \ (op \ n_1 \ n_2))}
\] \\

\vspace*{15pt}
Atomic: \
\[
\inference[String]{}
{s \ $$\Downarrow$$ \ s}
\]
\[
\inference[Integer]{}
{n \ $$\Downarrow$$ \ n}
\]
\[
\inference[List]{n \ $$\Downarrow$$ \ v}
{(n) \ $$\Downarrow$$ \ v}
\]

\vspace*{15pt}
Forms (F): \
\[
\inference[let]{t_0 \ $$\Downarrow$$ \ v}
{(\text{let } \ {[x \ (t_0)]} \ (t_1)) \ $$\Downarrow$$ \ t_1 {[}x \ $$\mapsto$$ \ v{]} }
\]
\[
\inference[if true]{{t_0} \ $$\Downarrow$$ \ \textsc{True} & t_1 \ $$\Downarrow$$ \ v}
{(if \ (t_0) \ t_1 \ t_2) \ $$\Downarrow$$ \ v) }
\]
\[
\inference[if false]{t_0 \ $$\Downarrow$$ \ \textsc{False} & t2 \ $$\Downarrow$$ \ v}
{(if \ (t_0) \ t_1 \ t_2) \ $$\Downarrow$$ \ v) }
\]
\[
\inference[cond]{t_0 \ $$\Downarrow$$ \ \textsc{False} & t_1 \ $$\Downarrow$$ \ \textsc{True} & t_3 \ $$\Downarrow$$ \ v}
{(cond \ (t_0) \ t_2 \ (t_1) \ t_3) \ $$\Downarrow$$ \ v) }
\]
\[
\inference[defn]{ {t_0 \ [x]} \ $$\Downarrow$$ \ v}
{(defn \ s \ {[x]} \ (t_0)) \ $$\Downarrow$$ \ s \ $$\mapsto$$ \ v }
\]
\[
\inference[fn]{ {t_0 \ [x]} \ $$\Downarrow$$ \ v}
{(fn \ {[x]}  \ (t_0) \ $$\Downarrow$$ \ v }
\]
\[
\inference[call to external function]{ {args*} \ $$\Downarrow$$ \ v}
{(s \ {args*}) \ $$\Downarrow$$ \ v }
\]
\[
\inference[recur]{ {args*} \ $$\Downarrow$$ \ v}
{(recur \ {args*}) \ $$\Downarrow$$ \ v }
\]\vspace*{10pt}

Recur emits all of its arguemnts and provides it as arguments to JavaScript 
\texttt{arguments.callee(args*)} function. \\
The \texttt{(s )} form that uses a string as a function, allows for invoking named function recursively, as well as any in-built JavaScript functions and library (e.g. jQuery) functions, as described in ~\ref{DOM}.
\caption{Lispish evaluation relations (Big-Step Semantics)}
\label{fig:lispish-big-step}
\end{figure}
