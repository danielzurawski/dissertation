\chapter{Implementation and Testing}
Following the formal definition of the Lispish language and briefly describing the operations of the compiler, we shall dive into the construction of it. Along the way, I will explain the concepts behind most of the mechanics of the compiler. 
In the following sections, we will also test the implementation by means of examples of an actual compilation. 
At the end, we will look into formalising those tests by means of using a testing API.  

\section{Building the compiler}
This section will describe the operations of the compiler and the fundamental concepts behind how the compilers translates the input Lispish code to JavaScript. 

\subsection{Recursive Expansion}
The main idea behind the Lispish compiler's implementation is recursive expansion.
The compiler breaks down each s-expression it comes across into its primitives until there is no more work to be done. It then buils up the result in layers as the recursion folds upwards. 

\begin{figure}[!htbp]
	\centering
	\includegraphics{Graphics/implementation_flowchart.jpg}
	\caption[yadayada]
   {Flow chart of \textit{Lispish to JavaScript} compilation.}
\end{figure}

Figure ~\ref{fig:recursive_expansion_flowchart} illustrates the functional flow chart of the compiler, without yet going deep into the details how s-expressions with multiply arity arguments are handled. 

\subsection{Forms with multiple arity (Map and reduce fns?)}

In order to solve the multiple arity problem, where for instance a (cond ) form can take multiple condition/true-form expression tuples and each one of them has to be individually compiled and them reduced to a string, a Map Reduce construct has been used. 

\subsubsection{Map}
The idea behind the map operation is to apply a function that takes one argument, to all of the elements in a collection and return a new collection with results of each application of the aforementioned function. 
A simple example of Map is 

\begin{verbatim}
(map (fn [x] (+ x 1)) 
	 [0 1 2 3 4 5])
\end{verbatim}
that yields 
\begin{verbatim}
[1 2 3 4 5 6]
\end{verbatim}
as a result

\subsection{Reduce}
Reduce generates a single result or a collection out of the application of a funcion to a collection.	

\begin{verbatim}
(reduce str 
	 [1 2 3])
\end{verbatim}
that yields 
\begin{verbatim}
"123"
\end{verbatim}
as a result. The collection of numbers has been reduced to a string, as each number was converted to a string and then a string of the collection has been produced.
If we would to map a "str" function over the collection of [1 2 3], it would result in a new collection containing all of the elements of the old collection converted to a string, namely this list ("1" "2" "3").

To now put the map reduce constructs into perspective with Lispish, here is how a multiple arity cond (allowing practically not bound list of tests) is implemented, that not only allows for multiple arity but also generates a different, yet equivalent JavaScript code: 

\begin{verbatim}
(defn emit-cond [head [name condition statement & rest]]
  (str "if(" (emit condition) ") { return " (emit statement) " }"
       (reduce str (interleave (map #(str "else if(" % ")")
                                    ;; Special case if condition is :else then emit "true"
                                    (reduce list (map #(if (= (str %) ":else") "true" (emit %))
                                                     (take-nth 2 rest))))
                               (map #(str "{ return " % " }")
                                    (map emit (take-nth 2 (pop rest)))))) ))
\end{verbatim}

Given an arbitrary number of "(test) result" tuples for the input (cond ) form, we are first emiting the first condition and the result statement: "if(" (emit condition) ") { return " (emit statement) " }". As we can see, we are concatenating the "if" symbol with the emitted condition that was passed as an argument to the function, then concatenating that with the ") { return " string and then concatenating that with the emitted true-form (emit statement), concatenated with the closing " }" string. 
The next step is to emit and interleave the else if and return parts of the JavaScript code, with the exception of the form ":else" which needs to produce and "else if (true)" and the second part of the tuple, which is the matching true form expression.
At the end of the emiting, we are reducing the interleaved emitted JavaScript snippets to a single combined string, which results in an elegant transformation of a Lisps (cond (test) true (test2) true2) to a JavaScript if-else-if expression.

\section{Testing}
The section above described the operations that are part of the compilation, but they did not provide any examples of an actual compilation. 
In this section we will take a look at some examples of how our Lispsh to JavaScript compiler performs. 
To illustrate the compilation, I will demonstrate the output of the recursive expansion that the compiler performs on the given s-expressions. 
Each line of the compilation trace will correspond to a level in the recursion. The recursion folding will be done implicitly, therefore it does not appear in the compilation traces. 

Let's begin our tests by a simple arithmetic expression:
\begin{verbatim}
lispish.core> (lisp-to-js (+ 2 2))
Emit Lispish:  (+ 2 2)
Emit-list head:  + , tail:  (2 2)
Emit-op, head:  + , tail:  (2 2)
Emit Lispish:  2
Emit Lispish:  2
"(2+2)"
\end{verbatim}
As we can see, our recursion begins with passing the Lispish source code to a lisp-to-js macro, which then begins the recursion by invoking the initial emit step.
At first, our s-expression is of the form (+ 2 2), which is a list. This means that the compiler has to expand the list and emit each individual expression within it. It begins by evaluating the head of the list, which happens to be an "op" operator, in this case the "+" sign. 
It therefore passes the head of the previous s-expression (the "+" sign), as well as the remaining part of the expression (2 2) to emit-op. 
Emit-op outputs the corresponding JavaScript by first mapping the top-level recursion emit function to each element inside of the tail list (2 2) which reaches the bottom of the recursion in one step each and then reduces the result of this to a string concatenated with the operator in the middle.
The same procedure is repeated for all of the "op", as well as "bop" expressions.

In the next sub section, we will have a look at a more complex example of generating a named function that is implemnted largely with Abstract Structural Binding.

\subsection{Abstract Structural Binding}
Abstract Sutrctural Binding in simple words means destructuring. It allows for destructuring any data structure to a corresponding argument in function parameters or a let form.
For example, if we define a let as follows:
\begin{verbatim}
(let [[x1 x2] [1 2]])
\end{verbatim}
"x1" will yield 1 and "x2" will yield 2.
The same principle is true for a function.
If our function accepts one parameter which is a collection:

\begin{verbatim}
(defn test [[x1 x2]] (println x1 x2))
(test [1])
\end{verbatim}
and it destructures the first two elements of the collection to x1 x2, in the above case, x1 will yield 1 and x2 null.


Lispish uses destructuring for generating all of its forms ($F$):
\begin{verbatim}
lispish.core> (lisp-to-js (defn square [x] (* x x)))
Emit Lispish:  (defn square [x] (* x x))
Emit-list head:  defn , tail:  (square [x] (* x x))
Emit-forms, head:  defn , full expression:  (defn square [x] (* x x))
Emit-defn, name:  square , arg:  x , arg tail:  nil , rest:  ((* x x))
Emit Lispish:  ((* x x))
Emit Lispish:  (* x x)
Emit-list head:  * , tail:  (x x)
Emit-op, head:  * , tail:  (x x)
Emit Lispish:  x
Emit Lispish:  x
"function square(x) {(x*x)}"
\end{verbatim}

In order to split the "defn" expression into into its respective elements, the emit-defn function that gets invoked by emit-list (after determining the head of list to be "defn") performs a structural binding of the function arguments. The bindings are then used to generate the equivalent JavaScript code. 

Lets look at the signature of the emit-defn function:
\begin{verbatim}
(defn emit-defn [type [defn name [arg & more] & rest]]
  )
\end{verbatim}
as we can see, the function takes 4 arguments and 2 optional tail arguments that can be a list of an arbitrary length. The "type" argument is simply a convinience placeholder for the head of the whole expression.
The actual expression begins to bind from the [defn name [arg \& more] \& rest] arguments. 
The optional more in the arguments list of arguments allows for an arbitrary length of the named function arguments and the optional rest is for the expression that follows the named function.

This structure can be then reused to output the corresponding JavaScript as follows:

\begin{verbatim}
(str "function "
  // Name of the function 
  name "("
    (if (nil? more) 
      // If arguments are not a list, then output just single argument
      arg 
      // Else output that list of arguments, separated by a comma
      (str arg ", " (clojure.string/join ", " more))
    )
    // Close the arguments parenthesis and begin function body
    ") {"
    // Emit function body
    (emit rest)
    // Close function body
    "}"
)
\end{verbatim}

\subsection{Deploying Lispish}
The end goal of this project was to be able to compile a source Lispish program to an equivalent JavaScript program.
It is however not ideal to have to perform compilation in an interactive REPL, where Clojure environment is set up. 

To solve this problem, Lispish compiler is compiled as a standalone JAR file that can be executed in any environment with the Java Runtime Environment installed. This is possible as the JAR file bundles the Clojure language itself, as well as all of its dependencies and our Lispish compiler. It then exposes the application through a simple static main method, which servers as an entry point to programs execution, similarily to standard Java applications. 

There are three simple ways to compile a Lispish program to JavaScript. T
he first method is to execute the lispish jar file and provide simple source code as a command line argument:

\begin{verbatim}
danielzurawski$ java -jar lispish-1.0.jar "(+ 2 2)"Emit Lispish:  (+ 2 2)
Emit-list head:  + , tail:  (2 2)
Emit-op, head:  + , tail:  (2 2)
Emit Lispish:  2
Emit Lispish:  2
(2+2)
\end{verbatim}

Given as an input a prefix s-expression of (+ 2 2), the program yields an expected result, which is an equivalent in-fix (2+2).

This approach is fine for trivial examples that do not span across multiple lines, it is however not optimal when we want to compile a Lispish program file to an equivalent JS. 
In order to compile a Lispish source file to an equivalent JavaScript source file, our compiler accepts two command line options:

\begin{verbatim}
["-in" "--input" "REQUIRED: Path to Lispish source code."]
["-out" "--output" "OPTIONAL: Path to JavaScript output file."]
\end{verbatim}

"-in" or equivalently "--input", that should follow with a path to a Lispish source file, as well as an optional 
"-out" or equivalently "--output", that should follow with the name of the output source file. 

To demonstrate how compilation of one source file to another is performed, here is the content of a sample "test.lispish" file:

\begin{verbatim}
danielzurawski$ more test.lispish
(+ 2 2)
\end{verbatim}

We can then execute the compiler passing in the -in and -out arguments, as follows:

\begin{verbatim}
danielzurawski$ java -jar lispish-1.0.jar -in /Users/danielzurawski/git/lispish/test.lispish -out test.js
Emit Lispish:  (+ 2 2)
Emit-list head:  + , tail:  (2 2)
Emit-op, head:  + , tail:  (2 2)
Emit Lispish:  2
Emit Lispish:  2
danielzurawski$
\end{verbatim}

Our "-in" argument is an asbolute path to the "test.lispish" file that we printed in the code snippet above and our "-out" argument is the name of the file to be generated, to which the compiler will yield result. 
The compiler will print out all of the computation steps to the console, but the final result that is the JavaScript output will be written to a file.

Now, if we check the content of test.js, we can see
\begin{verbatim}
danielzurawski$ more test.js
(2+2)
danielzurawski$
\end{verbatim}
that the test.js file yields the compiled JavaScript source code. 

This however is a rather trivial example, that does not span accross multiple lines, so lets try something a bit more sophisticated:

The following snippet illustrates the translation of a recursive Ackermann Function [REFERENCE HERE ] from a Lispish source code, to its equivalent JavaScript. 

\begin{verbatim}
danielzurawski$ java -jar lispish-1.0.jar -in /Users/danielzurawski/git/lispish/test.lispish -out test.js
Emit Lispish:  (defn ackermann [m n] (cond (= m 0) (+ n 1) (= n 0) (ackermann (- m 1) 1) :else (ackermann (- m 1) (ackermann m (- n 1)))))
Emit-list head:  defn , tail:  (ackermann [m n] (cond (= m 0) (+ n 1) (= n 0) (ackermann (- m 1) 1) :else (ackermann (- m 1) (ackermann m (- n 1)))))
Emit-forms, head:  defn , full expression:  (defn ackermann [m n] (cond (= m 0) (+ n 1) (= n 0) (ackermann (- m 1) 1) :else (ackermann (- m 1) (ackermann m (- n 1)))))
Emit-defn, name:  ackermann , arg:  m , arg tail:  (n) , rest:  ((cond (= m 0) (+ n 1) (= n 0) (ackermann (- m 1) 1) :else (ackermann (- m 1) (ackermann m (- n 1)))))
Emit Lispish:  ((cond (= m 0) (+ n 1) (= n 0) (ackermann (- m 1) 1) :else (ackermann (- m 1) (ackermann m (- n 1)))))
Emit Lispish:  (cond (= m 0) (+ n 1) (= n 0) (ackermann (- m 1) 1) :else (ackermann (- m 1) (ackermann m (- n 1))))
Emit-list head:  cond , tail:  ((= m 0) (+ n 1) (= n 0) (ackermann (- m 1) 1) :else (ackermann (- m 1) (ackermann m (- n 1))))
Emit-forms, head:  cond , full expression:  (cond (= m 0) (+ n 1) (= n 0) (ackermann (- m 1) 1) :else (ackermann (- m 1) (ackermann m (- n 1))))
Emit Lispish:  (= m 0)
Emit-list head:  = , tail:  (m 0)
Emit-op, head:  = , tail:  (m 0)
Emit Lispish:  m
Emit Lispish:  0
Emit Lispish:  (+ n 1)
Emit-list head:  + , tail:  (n 1)
Emit-op, head:  + , tail:  (n 1)
Emit Lispish:  n
Emit Lispish:  1
Emit Lispish:  (= n 0)
Emit-list head:  = , tail:  (n 0)
Emit-op, head:  = , tail:  (n 0)
Emit Lispish:  n
Emit Lispish:  0
Emit Lispish:  (ackermann (- m 1) 1)
Emit-list head:  ackermann , tail:  ((- m 1) 1)
Emit-forms, head:  ackermann , full expression:  (ackermann (- m 1) 1)
emit-recur, head: ackermann , name:  ackermann , args:  (- m 1) , more:  (1)
Emit Lispish:  (- m 1)
Emit-list head:  - , tail:  (m 1)
Emit-op, head:  - , tail:  (m 1)
Emit Lispish:  m
Emit Lispish:  1
Emit Lispish:  1
Emit Lispish:  (ackermann (- m 1) (ackermann m (- n 1)))
Emit-list head:  ackermann , tail:  ((- m 1) (ackermann m (- n 1)))
Emit-forms, head:  ackermann , full expression:  (ackermann (- m 1) (ackermann m (- n 1)))
emit-recur, head: ackermann , name:  ackermann , args:  (- m 1) , more:  ((ackermann m (- n 1)))
Emit Lispish:  (- m 1)
Emit-list head:  - , tail:  (m 1)
Emit-op, head:  - , tail:  (m 1)
Emit Lispish:  m
Emit Lispish:  1
Emit Lispish:  (ackermann m (- n 1))
Emit-list head:  ackermann , tail:  (m (- n 1))
Emit-forms, head:  ackermann , full expression:  (ackermann m (- n 1))
emit-recur, head: ackermann , name:  ackermann , args:  m , more:  ((- n 1))
Emit Lispish:  m
Emit Lispish:  (- n 1)
Emit-list head:  - , tail:  (n 1)
Emit-op, head:  - , tail:  (n 1)
Emit Lispish:  n
Emit Lispish:  1
\end{verbatim}

The ackermann function is a fairly complicated function that spans across multiple lines and in order to produce an equivalent JavaScript code, a fair amount of recursive calls has to be performed, thus the trace of execution is a rather lengthy one. 

If we now examine the test.js file, it yields:

\begin{verbatim}
danielzurawski$ more test.js
function ackermann(m, n) {if((m==0)) { return (n+1) }else if((n==0)){ return ackermann((m-1), 1) }else if(true){ return ackermann((m-1), ackermann(m, (n-1))) }}
\end{verbatim}

We can now test whether the code can be executed in a JavaScript environment by testing it in for example Google Chrome Console: 

\begin{verbatim}
> function ackermann(m, n) {if((m==0)) { return (n+1) }else if((n==0)){ return ackermann((m-1), 1) }else if(true){ return ackermann((m-1), ackermann(m, (n-1))) }}
> ackermann(1, 3)
5
\end{verbatim}

As we can see, the Google Chrome web browsers console can evaluate the function and when executed with parameters, it yields the right result. 

\subsection{Automating tests with clojure.test API}
In order to ensure that the compiler is naturally expanded and all of the of regression tests are performed whenever a new language construct is added, I have decided to use the Test Driven Development methodology to approach this project. 
The tool to support me in the task of TDD I used was the clojure.test API.
clojure.test API [REFERENCE HERE] is a unit testing framework that provides a set of in-built forms, particularly the "is" macro that allows to perform boolean assertions on arbitrary expressions. 

\begin{quote}
\begin{verbatim}
(deftest factorial-example
  (is (= "function factorial(n) {if(n<2) { return 1 } else { return (n*factorial(((n-1)))) }}"
         (lisp-to-js (defn factorial [n] (if (< n 2) 1 (* n (factorial (- n 1)))))))))
\end{verbatim}
\end{quote}

