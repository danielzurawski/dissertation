\chapter{Conclusions and Future Work}

Functional compilers provide an elegant alternative to compilers written in imperative languages. Nevertheless, it is not trivial to implement one given the relative unpopularity of functional programs. 

The translator in its current state could be a good foundation for initiating a collaboration with the open source community that could have interest in extending it. 

It was not in the scope of this project to provide any formal proofs of the correctness of the translations. This, however, would be a very achievable target, mainly due the functional properties of the compiler -- namely the one-input/one-output property. 
Providing formal proofs for the correctness of the translator and even further, of the generated translations could be a good project for a Master's Thesis. 

\section{Future work}
\subsection{Macros}
It is typical for Lisp languages to provide a way to define new constructs in terms of already existing language constructs.
For this to happen, a language needs to support macros which 
provide a way to extend the language at compile time. 
Due to time constraints, I was unable to perform sufficient research into how to provide the flexibility of macros, while still being able to parse the code correctly. 

\subsection{Parser}
In order for the Lispish translator to be a true compiler, it would need a parser that can decide whether the input string, that is the Lispish program, is in fact valid. As mentioned in the previous chapter, the current compiler does not provide any error detection facilities and this therefore, would be the first step to proper error handling. 

\subsection{Supporting a Greater Subset of Clojure}
Lispish implements a fair subset of Clojure. Adding support for a bigger subset
(if not the entirety of the language) is a reasonable next step should further development occur. This would be facilitated by the project's design which allows for extending the functionality in this respect.

\subsection{Code Optimisation}
One possible improvement, that was outside of the scope of this project, would be to optimise the input that the compiler receives before transforming it into JavaScript. Possible optimisations could include removing dead code and  computing the value of constant expressions.

\subsection{JavaScript Strict Mode Compliance}
Due to the use of the \texttt{arguments.callee} function used to facilitate the implementation of the \texttt{(recur )} form (see the relevant implementation section \ref{arguments.callee} on page \pageref{arguments.callee}), the compiler's output is not Strict mode compliant and thus, might not run should that be enabled.
Creating an alternative solution that would bring the output code into compliance would be a worthwhile pursuit.
