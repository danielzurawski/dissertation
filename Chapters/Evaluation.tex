\chapter{Evaluation}
The implementation of the Lispish to JavaScript translation was supposed to serve as an example of how a programming language translator can be implemented using a functional language.

The parsing of the language is greatly simplified and inherently free of error, as the translator takes an advantage of the inherent feature of the Clojure language, which is its homoiconity and the Clojure reader that is responsible for parsing the input source files and producing the corresponding objects, as described in the design section of the report.


\section{Specification Requirements}

Sections below summarise whether the goals of the projects outlined in section \ref{requirements} have been met:

\subsection{Formal Definitions of the Lispish Grammar Rules and Evaluation Relations}
Chapter 3 provided well-defined descriptions of the Lispish grammar and its evaluation relations. 
The rest of the implementation remained true to these formal definitions of Lispish and it provided the facility to generate the equivalent JavaScript code.

\subsection{Implementation of the Lispish to JavaScript Translator}
As showcased throughout the Implementation chapter of the report, the translator has been completed with a great success, as it is capable of translating non-trivial Lispish programs into its equivalent JS code that successfully executed. 
Partially by coincidence, it also allows for manipulating DOM documents, which makes for a great additional feature.

\subsection{Test Coverage for Regression Testing}
Appendix B provides a set of unit tests that include multiple real applications of our translator by translating small Lispish programs including Fibonacci sequences, factorial, Ackermann and naive primality checking to its equivalent JavaScript programs, as well as smaller tests that check the correctness of single forms.

The unit tests included in the above mentioned appendix all successfully pass.

\subsection{Command Line Interface}
The requirement of providing a CLI has been successfully met. 
Implementation allows for feeding the input source files as a CLI argument or alternatively by providing the \texttt{--input} and \texttt{--output} paths to file. Deploying and using Lispish has been discussed in section \ref{deploying-lispish}.

As a result of design decisions, Lispish is not strictly a subset of Clojure, as there is a small number of cases, where certain form inputs are not allowed.
These exceptions include:

\noindent Lispish/Clojure inconsistencies:

\begin{itemize}
\item The \texttt{(let )} form only supports 1 argument, but it can be anything, including an anonymous function just like in strict Clojure.
\item Strict Clojure allows for \texttt{(cond )} with an optional :else argument at the end. Due to a design decision, \texttt{:else} is strictly required.
\end{itemize}


The JavaScript code that is generated by the translator does not provide any optimisations and it makes a heavy use of recursion, which is of course not optimal for any real applications. 

It is not certain how severely this implementation affects the performance of the translated code, as the JavaScript V8 compiler could, in theory, optimise all of the \texttt{arguments.callee} recursive calls using tail recursion. 
This paper does not provide any benchmarks as to how the generated code performs compared to code for programs that would be hand written in JavaScript. 

The grammar of Lispish allows for identifier names separated with the \texttt{-} dash symbol, which after translation, results in an invalid JavaScript, as the dash character cannot be used as part of an identifier in JavaScript.

\section{Missing parts}
\subsection{Error handling}
The compiler does not provide any facility for error reporting during the compilation.

The compiler does not have any means of validating the JavaScript code. This could be incorporated by means of bundling a JavaScript validator that could simply analyse the code before it is saved to an output file. This was, however, not part of the initial design and due to time constraints has not been implemented.

The biggest issue with the compiler is that it does not actually parse the input string before the compilation is performed. This caveat removes the possibility of determining if the input source, that is Lispish, is actually valid. 
Providing an invalid Lispish source code would still result in a JavaScript output, but the generated code would be malformed and would not execute in a browser. This is both true for semantical, as well as syntactical errors.

\section{Evaluating Lispish against other Lisp-to-JavaScript Compilers}\label{lispish-vs-rest}

\subsection{ClojureScript}

Lispish does not try to compete with other compilers such as ClojureScript (as they are community-driven, mature and production ready) that not only provide a much larger language support, but also the very crucial optimisations that a toy implementation such as Lispish does not provide. In its current version, 

ClojureScript does not define a subset of Clojure that it can compile, therefore it is implied that it provides a full language coverage. In contrast, Lispish defines limited language constructs that can be used to build simple programs and therefore, it is nowhere as powerful as ClojureScript.

\subsection{Outlet}

Outlet just like LiScript defines its own language that then gets translated to its equivalent JavaScript. However, it does not provide a formal definition of the allowed forms, nor the evaluation relations. Lispish provides both -- the big-step evaluation relations and grammar definition are in the design \& specification section~\ref{design-specification}.

In contrast with Outlet, Lispish takes advantage of the popular Clojure language and proposes translating a small subset of the language to JavaScript.Outlet defines it's own original Lisp-like syntax that must be understood by a Clojure or Lisp programmer, before even a trivial program can be implemented.
One of the advantages of Outlet is that it allows the programmer to extend the language using macro functions, whereas Lispish does not provide macros and thus has a much lower flexibility compared to Outlet.

\subsection{LiScript}

LiScript, similarly to Lispish, takes an advantage of JavaScripts functional nature and as quoted from its project page "\textit{it does not try to make it a completely different language - which is the root of many common problems such as messy generated code, overheads, painful compilation and hard debugging - all of which compensate for the theoretical benefits."} \cite{LiScript:2013:Site}.

Similarily to Outlet it does not take an advantage of an existing Lisp language and instead, it defines its own Lisp-like language. 

\subsection{ClojureJS}

ClojureJS proposes an approach that differs from all of the above mentioned languages, except for the vaguely similar in its nature ClojureScript. Similarly to ClojureScript, the ClojureJS generates a more imperative JavaScript and provides a better layer of interaction over JavaScript, allowing for imperative constructs such as loops. 
Due to its more imperative nature, all of ClojureJS forms have an implicit return, which as identified during the implementation of Lispish causes serious problems when defining programs with nested expressions. \\

In retrospect, Lispish has been designed to provide a solid, but restricted amount of functionalities, that have been all formally documented and it accomplishes its goal.
