\chapter{Evaluation}
The implementation of Lispish to JavaScript was supposed to serve as an example of how a programming language translator can be implemented using a functional language.

Due to its functional nature and immutability, it does not suffer from errors caused by inconsistent state, as there is no state. The compiler will always produce a result. The result however is not guaranteed to be correct, if an incorrect input has been provided.

The parsing of the language is greatly simplified and inherently free of error, as the translator takes an advantage of the inherent feature of the Clojure language, which is its homoiconity and the Clojure reader that is responsible for parsing the input source files and producing the corresponding objects, as described in the design section of the report.

Appendix~\ref{tests-appendix} provides a set of unit tests that include multiple real applications of our translator by translating small Lispish programs including Fibonacci sequences, factorial, ackermann and naive primality checking to its equivalent JavaScript programs, as well as smaller tests that check the correctness of single forms.
The unit tests included in the above mentioned appendix all successfully pass.
The compiler also successfully compiles a given input file to an output file with name of our choice. 

As a result of design decisions, Lispish is not strictly a subset of Clojure, as there is a small number of cases, where certain form inputs are not allowed.
These exceptions include:

\noindent Lispish/Clojure inconsistencies:

\begin{itemize}
\item The \texttt{(let )} form only supports 1 argument, but it can be anything, including an anonymous function just like in strict Clojure.
\item Strict Clojure allows for \texttt{(cond )} with an optional :else argument at the end. Due to a design decision, \texttt{:else} is strictly required.
\end{itemize}


The JavaScript code that is generated by the translator does not provide any optimisations and it makes a heavy use of recursion, which is of course not optimal for any real applications. 
It is not certain how severely this implementation affects the performance of the translated code, as the JavaScript V8 compiler could, in theory, optimise all of the \texttt{arguments.callee} recursive calls using tail recursion. 
This paper does not provide any benchmarks as to how the generated code performs compared to code for programs that would be hand written in JavaScript. 

The grammar of Lispish allows for identifier names separated with the \texttt{-} dash symbol, which after translation, results in an invalid JavaScriot, as the dash character cannot be used as part of an identifier in JavaScript.

\section{Missing parts}
\subsection{Error handling}
The compiler does not provide any facility for error reporting during the compilation.

The compiler does not have any means of validating the JavaScript code. This could be incorporated by means of bundling a JavaScript validator that could simply analyse the code before it's served to an output file. This was however not part of the initial design and due to time constraints has not been implemented.

The biggest issue with the compiler is that it does not actually parse the input string before the compilation is performed. This caveat removes the possibility of determining if the input source, that is Lispish, is actually valid. 
Providing an invalid Lispish source code would still result in a JavaScript output, but the generated code would be malformed and would not execute in a browser. This is both true for semantical, as well as syntactical errors.