\chapter{Background}
The background should set the project into context by motivating the subject matter and relating it to existing published work. The background will include a critical evaluation of the existing literature in the area in which your project work is based and should lead the reader to understand how your work is motivated by and related to existing work.

This section provides a throghout background research of the domain of functional programming, Lisp and JavaScript that lead me to the rational behind Lispish design decisions.

\section{Bridging the gap between functional and imperative paradigm}

\subsection{Functional and imperative paradigms comparison}
Functional programming is a programming paradigm that differs from imperative programming in a way that it focuses solely on evaluating functions, where one input always results in the same output for a given input (referential transparency). In imperative programming, this notion is not always true, as imperative programming focuses a lot more on modyfing the state of the application as it runs. To make referential transparency, pure functional languages try to avoid using state and mutability, by ensuring that side effects that could introduce state changes are not possible.

An example of state is preserving results in variables for later access by other parts of the program. A side effect may result from many different operations such as variable assignments, input or output operations and anything that allows two parts of the program to access the same resource at the same time.

Due to the increase of the demand for parallelisation, as more processing cores are added to modern CPUs, it is therefore essential that the software we write can be parallelised easily and without the risk of errors that could be caused by race conditions or deadlocks - which are all caused by the notion of mutability that is present in imperative languages.

The notion of pure functions may sound very impractical for a general purpose programming language, therefore functional languages used by practicioneers such as Clojure allow state, but lexicaly scoped to its own function.
When state is absolutely necessary in order to improve the performance of an application or expose variable to other parts of the program, Clojure allows for so called "atoms", that improve on the classical notion of a variable, as it is still immutable, but instead an atomic swap operation of the content is performed whenever want to override the original state.

The property of immutability is also preserved for data structures, as each time a data structure is modified, a new copy of such structure is retained therefore leaving the old one in tact. This allows for much better parallelisation, as one part of the program may never modify the same data as the other part of the program, which would lead to inconsistent state.

\section{Programming languages involved}
In order to complete this project, it is necessary not only to understand the two different programming paradigms, but also the specific features of each of the languages involved - Clojure and JavaScript, as Lispish is a subset of Clojure and the compiler itself is also programmed in Clojure.

\subsection{Clojure}
Clojure is a functional language, which is implemented as a dialect of Lisp and primarily targets the Java Virtual Machine. It can also target Microsoft's Common Language Runtime, which is the virtual machine for the .NET Framework through Clojure's sub-project \textbf{clojure-clr} [REFERENCE HERE https://github.com/clojure/clojure-clr]. 
It also targets JavaScript by means of \textbf{ClojureScript} [REFERENCE HERE https://github.com/clojure/clojurescript], which is a subset of Clojure that compiles to JavaScript. 

Clojure is a powerful abstraction over standard Java, which as of today does not provide lambdas and any of the functional constructs that Clojure does, including immutability and treating code as data.

\subsubsection{Lisp}

Lisp is amongst one of the worlds oldest family of programming languages, that has developed several dialects since the original Lisp was published in 1958-1960 by John McCarthy. [citation here]
Lisp languages differ from other programming languages in its few original concepts, notably treating code as data, s-expressions, parenthesized Polish prefix notation and lambda expressions.

The exact expansion of the Lisp acronym is List Processing, which has its practical reasons - Lisp source code is written as lists, formally - S-Expressions [reference here]

To illustrate how a valid s-expression would look like compared to an equivalent C expression, here is an example:

\begin{quote}
\begin{verbatim}
1 == (1 * 1)
\end{verbatim}
\end{quote}
in C is equivalent to

\begin{quote}
\begin{verbatim}
(= 1 (* 1 1))
\end{verbatim}
\end{quote}
in Lisp's s-expression based prefix notation.

\subsubsection{Portability}
Due to the fact that Clojure targets the JVM, programs written in this language can be executed in any environment where the JRE is installed by means of executing Clojure programs packaged as JAR files, given that they have been packaged to include Clojure itself.  

Clojure programs can co-operate with Java applications due to its great interoperability. They can be imported into Java programs as aforementioned JAR files.
Clojure can also access all of the core Java static classes/methods, making it a very powerful abstraction over Java, not only because it's a very portable, functional language that works with immutable data structrues, but also because it gives an access to the vast Java libraries and the entire JVM eco-system.

\subsection{JavaScript}
JavaScript is an interpreted, dynamically typed, object-oriented programming language that originated from the ECMAScript language in 1995 [REFERENCE HERE]. It was originally intended as a client side scripting language for web browser, but it has since evolved to an extent where well-known corporations such as Microsoft use it for their server side processing [REFERENCRE HERE] due to its rich support for multiple programming styles, including functional programming at its core.

\subsubsection{JavaScript performance}
The invention of the V8 Google JavaScript Engine made JavaScript stand out from other dynamic languages by making it faster than other dynamically types languages such as for e.g. Python [reference required].

Due to the fact that Lispish compiles to JavaScript, the generated code can be treated with various optimisation techniques, including the Google Closure compiler that minimises and optimises the code, by compiling the readable, yet verbose version of the JavaScript code, to a less readable but highly optimised JS code.

\subsubsection{Portability}
JavaScript interpreters are present on majority of consumer devices and are present in all of the modern web browsers. It is the basis of Rich Internet Applications and is now not only present on the front end of the web browser, but also servers as a language of choice for back ends.
Most notable examples include Microsoft's cloud platform Windows Azure that operates using JavaScript both on the front end and as well as the back end, making use of the Node.Js framework for producing highly asynchronous web applications. [reference required]

\subsection{Compiling Lispish using a dialect of Lisp}
The decision to use Clojure to write a compiler for my Lisp language comes from the fact that there are large advantages of using Lisp to compile Lisp.
The nature of Lisp and it's s-expressions allows us to build efficient recursive descent parsers that can take the advantage of the already present functions in our implementation language, Clojure.

Some of the typical complexities that we would encounter when trying to implement a Lisp compiler using a non-lisp imperative language such as C include having to determine if a given expression is an s-expression (list) or a symbol and then breaking the input down into its atomic form of tokens to then building a Parse Tree (ST) or an Anotated Syntax Tree (AST).
In our case, our input s-expressions with their prefix notations can be treated as a parse tree and thanks to the in-built functions, we can greatly simplify the compiler.

For example, any s-expression can be essentially type-checked using the inbuit "symbol?" or "list?" to determine if the given s-expression yields to a symbol or a list of expressions. If an input is a list, that means we have come across another s-expression and each element in the list has to be separetly evaluated.

Modern dialects of Lisp, such as Clojure, target the Java Virtual Machine making them very portable and pluggable into an existing Java applications.
Other Lisp languages are very often compiled to another target language, such as C or JavaScript that can be then run on a variety of machines.

\section{JavaScript as a target language for the Lispish language}
The rationale behind selecting JavaScript as the target language is the fact that JavaScript can be executed on almost all of the Internet enabled devices, as long as they have a web browser. Percentage of JS enabled devices as of date: [insert reference here].

Our small dialect of Lisp (Lispish) language will allow generating pluggable JavaScript code.
From this follows the fact that applications written in Lispish can be executed in environments where the JVM or Clojure is not present, as the generated code will be a standard JavaScript.
In theory our language could even be used as a Domain Specific Language (DSL) for JavaScript applications, as long as the code would be evaluated by our compiler in a Clojure JVM environment.

JavaScript offers a great opportunity as a target language for any high-level programming language primarily due to two reasons - it's portability and performance.

\subsection{Similarities}
JavaScript is a prototype based, objected-oriented language that due to its great flexibility and full support for lambda expressions can also be classified as a functional language.
\begin{quote}
\begin{verbatim}
// Attach event listener to the argument
var assign-event-listener = function(x) {
  x.addEventListener("load", function() {
    alert("All done");
  }, false)
};
\end{verbatim}
\end{quote}

Above example illustrates a stored function that takes a reference to a web browsers window as an argument and attaches an event listener to it. The listener then takes two arguments, a string descripting the event - here "load" and the callback function - here an anonymous function that displays an alert "All done" that gets displayed after the desired event is triggered.
To now show the similary between how the same expression could look like in Lisp, take for instance:

% Stworzyc nowy environment e.g. code z center i verbatim
\begin{quote}
\begin{verbatim}
(defn assign-event-listener [window]
  "Attach event listener to the argument"
  (window (addEventListener
           "load"
           (fn [x] (alert "All done")))))
\end{verbatim}
\end{quote}

Both of the expressions make use of nested functions and thus take the advantage of the lambda calculus. This abstraction can be also one-to-one mapped when peforming the compilation from a Lisp to JavaScript and thus simplyfing the compiler.

\section{Existing Lisp to JS compilers}
There already exists a number of similar projects, that each tries to solve the problem in a slightly different way, although there exists only one mature compilar that can actually generate an executable JavaScript code and it's called ClojureScript.

\subsection{ClojureScript}
ClojureScript is a Clojure to JavaScript compiler that can already generate code that can be executed in the browser and although there are examples of companies using ClojureScript for their production applications, it is difficult to operate as it requires to execute a chain of operations, including starting a JavaScript program before the Clojure code can be compiled.
ClojureScript also takes the idea further and utilises Google Closure compiler to optimise the code to remove code that can be reduced, thus making it run faster, but this approach also sufers from the fact that the Closure optimising compiler very often breaks the JavaScript code that was compiled from Clojure.

\subsection{Outlet}
Outlet [https://github.com/jlongster/outlet] is a Lisp-like programming language that compiles to JavaScript. 
It's compilation is interesting in that the compiler itself is written in Outlet, only after it is bootstraped by a JavaScript interpreter.
The bootstraping interpreter is implemented using grammar rules similar to Backus-Naur Form context-free grammars [http://blog.oleganza.com/post/106246432/recursive-descent-parser-in-javascript], thus ensuring that the initial interpretation of the main constructs is correct. 
This approach provides a solid foundation for then implementing rest of the constructs of the Outlet language, in Outlet.

Outlet does not provide the ability to define macros, thus there is no way to dynamically extend the language without modifying the compilers source, which is a big feature of a Lisp language.

\subsection{LiScript}
LiScript [REFERENCE HERE https://github.com/viclib/LiScript] is again a Lisp language that compiles to JavaScript. It supports roughly 20 forms, out of which 13 forms replace the normal binary and arithmetic operations of ">" "<" etc. and the remaining 7 are forms such as "if", anonymous function "fn", iterating constructs such as "iter" and "while".

LiScript is implemented in JavaScript and it is suprisingly lightweight. The entire implementation is around 100 lines of code, but nonetheless it can generate a readable and most importantly executable JavaScript code. 

LiScript allows defining new language constructs by means of macros, a special form "defmacro". That enables for building new forms from arbitrary strings, as input to the defmacro form first modifies the code and only then evalutes it. 

\subsection{clojurejs}
ClojureJS is a small subset of Clojure to JavaScript compiler.
ClojureJS takes on a different approach to the preceeding implementations, as the compilers is written in Clojure. 
It is a hand-written recursive descent parser that requires a running Clojure environment in order to evaluate input source code, which is of the form of a subset of Clojure.

ClojureJS proposes the idea of Special Forms, which are JavaScript specific functionalities, as well as an informally-defined set of forms that is a subset of Clojure.

ClojureJS is perhaps the second best implementation of Clojure to JavaScript compilation, with its support of macros and a lot larger subset of Clojure than for instance LiScript. 
It is however, in my opinion, a non-extensible implementation of a trans-compiler and it does not provide any ease-of-use features, such as being able to generate an output .js file out of a given source input. 
