\chapter{Design \& Specification}

\section{Development methodology}



\subsection{TDD}

\section{Designing the Lispish language}

Lispish is a dynamically typed, functional language that implements a call-by-value strategy just as its superset Clojure.

The formal description of Lispish behaviour will be described using transition systems.

\subsection{Syntax of Lispish}

term $\Coloneqq \ () \ \vert \ n \ \vert \ b \ \vert \ (bop \ t1 \ t2) \ \vert \ (op \ t1 \ t2) \\ $

where \\

op (arithmetic operator) $\Coloneqq \ + \ \vert \ - \ \vert \ * \ \vert \ /$
\\
bop (binary operator) $\Coloneqq \ > \vert < \vert =$
\\
n $\Coloneqq integer $
\\
() $\Coloneqq list $
\\
b $\Coloneqq boolean $
\\ 
x $\Coloneqq locally scoped variable $

special forms 
$\Coloneqq \ (let \ [binding] \ (expression)) \\
| \	(if \ (t0) \ t1 \ t2) \\
| \	(defn \ name \ [args*] \ (expression)) \\
| \	(fn \ [arg] \ (expression)) \\ 
| \	(cond \ (t0) \ t2 \ (t1) \ t3) \\
$

\subsection{Evaluation relations (Big-Step Semantics)}

\[ 
\inference[integer]{}
{n \ $$\Downarrow$$ \ n}
\]
\[ 
\inference[list]{}
{(n) \ $$\Downarrow$$ \ n}
\]
\[
\inference[let]{t_0 \ $$\Downarrow$$ \ v}
{(\text{let } \ {[x \ (t_0)]} \ (t_1)) \ $$\Downarrow$$ \ t_1 {[}x \ $$\mapsto$$ \ v{]} }
\]
\[
\inference[if true]{{t_0} \ $$\Downarrow$$ \ \textsc{True} & t_1 \ $$\Downarrow$$ \ v}
{(if \ (t_0) \ t_1 \ t_2) \ $$\Downarrow$$ \ v) }
\]
\[
\inference[if false]{t_0 \ $$\Downarrow$$ \ \textsc{False} & t2 \ $$\Downarrow$$ \ v}
{(if \ (t_0) \ t_1 \ t_2) \ $$\Downarrow$$ \ v) }
\]
\[
\inference[cond]{t_0 \ $$\Downarrow$$ \ \textsc{False} & t_1 \ $$\Downarrow$$ \ \textsc{True} & t_3 \ $$\Downarrow$$ \ v}
{(cond \ (t_0) \ t_2 \ (t_1) \ t_3) \ $$\Downarrow$$ \ v) }
\]
\[
\inference[defn]{ {t_0 \ [x]} \ $$\Downarrow$$ \ v}
{(defn \ s \ {[x]} \ (t_0)) \ $$\Downarrow$$ \ s \ $$\mapsto$$ \ v }
\]
\[
\inference[fn]{ {t_0 \ [x]} \ $$\Downarrow$$ \ v}
{(fn \ {[x]}  \ (t_0) \ $$\Downarrow$$ \ v }
\]



\section{Compiling Lispish to JavaScript}

\subsection{Compilation pipeline (use case/state machines?)}
Macros, treating code as data etc.

